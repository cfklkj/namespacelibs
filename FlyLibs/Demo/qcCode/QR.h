#include <iostream>
#include "cmd_console_tools.h"

const int N = 300;
const int type = 4;     //type表示8 - bit Byte的编码形式
const int error = 0;    //纠错级别，M

const HANDLE hout = GetStdHandle(STD_OUTPUT_HANDLE); //取标准输出设备对应的句柄
const HANDLE hin = GetStdHandle(STD_INPUT_HANDLE);  //取标准输入设备对应的句柄

struct code {
	int show;   //每个块的数据\颜色，0表示白，1表示黑
	int ifempty;  //位置是否为空，1表示空，0表示被占用,-1表示不可更改
};

/*存放多项式信息的双向链表*/
typedef struct polynode {
	int coef;    //系数
	int expofa;     //a的幂
	int expn;       //指数
	struct polynode *prior;  //前驱
	struct polynode *next;	//存放直接后继的指针
} polynode, *polynomail;

/*选择二维码level*/
int code_level(int n, int *level);
/*定位框*/
void draw_pos(int x, int y, code ccode[71][71]);
/*画小方框*/
void draw_box(int x, int y, code ccode[71][71]);
/*定位框边上的白框*/
void pos_side(int version, code ccode[71][71]);
/*数据转化*/
void code_bit(unsigned char *readin, char *data, int lenth1, int lenth2);
/*GBK编码转换到UTF8编码*/
int code_GBKToUTF8(unsigned char * lpGBKStr, unsigned char * lpUTF8Str, int nUTF8StrLen);
/*将单个字符转化成二进制形式*/
void code_single(char temp[16], unsigned char word);

/*字符数组内八位“二进制”转十进制,返回十进制值*/
int code_bina(char *data);

const int AlphaTo[255] = { 1,2,4,8,16,32,64,128,29,58,116,232,205,135,19,38,       //一行16个
76,152,45,90,180,117,234,201,143,3,6,12,24,48,96,192,
157,39,78,156,37,74,148,53,106,212,181,119,238,193,159,35,
70,140,5,10,20,40,80,160,93,186,105,210,185,111,222,161,
95,190,97,194,153,47,94,188,101,202,137,15,30,60,120,240,
253,231,211,187,107,214,177,127,254,225,223,163,91,182,113,226,
217,175,67,134,17,34,68,136,13,26,52,104,208,189,103,206,
129,31,62,124,248,237,199,147,59,118,236,197,151,51,102,204,
133,23,46,92,184,109,218,169,79,158,33,66,132,21,42,84,
168,77,154,41,82,164,85,170,73,146,57,114,228,213,183,115,
230,209,191,99,198,145,63,126,252,229,215,179,123,246,241,255,
227,219,171,75,150,49,98,196,149,55,110,220,165,87,174,65,
130,25,50,100,200,141,7,14,28,56,112,224,221,167,83,166,
81,162,89,178,121,242,249,239,195,155,43,86,172,69,138,9,
18,36,72,144,61,122,244,245,247,243,251,235,203,139,11,22,
44,88,176,125,250,233,207,131,27,54,108,216,173,71,142 };
//AlphaTo[n]的值为a的n次幂 n=0,1,2,...,254  得到系数
const int PowerOf[255] = { 0,1,25,2,50,26,198,3,223,51,238,27,104,199,75,4,
100,224,14,52,141,239,129,28,193,105,248,200,8,76,113,5,
138,101,47,225,36,15,33,53,147,142,218,240,18,130,69,29,
181,194,125,106,39,249,185,201,154,9,120,77,228,114,166,6,
191,139,98,102,221,48,253,226,152,37,179,16,145,34,136,54,
208,148,206,143,150,219,189,241,210,19,92,131,56,70,64,30,
66,182,163,195,72,126,110,107,58,40,84,250,133,186,61,202,
94,155,159,10,21,121,43,78,212,229,172,115,243,167,87,7,
112,192,247,140,128,99,13,103,74,222,237,49,197,254,24,227,
165,153,119,38,184,180,124,17,68,146,217,35,32,137,46,55,
63,209,91,149,188,207,205,144,135,151,178,220,252,190,97,242,
86,211,171,20,42,93,158,132,60,57,83,71,109,65,162,31,
45,67,216,183,123,164,118,196,23,73,236,127,12,111,246,108,
161,59,82,41,157,85,170,251,96,134,177,187,204,62,90,203,
89,95,176,156,169,160,81,11,245,22,235,122,117,44,215,79,
174,213,233,230,231,173,232,116,214,244,234,168,80,88,175 };
//PowerOf[n-1]的值是a的幂数 n=1,2,...,255  得到幂
int alphato(int n);
int powerof(int n);

struct code_block {
	int total;   //总块数
	int piece[2];  //将数据分为两组，每组的块数
	int divide[2][2];   //kr,每块的数据长度和纠错码长
};

/*计算纠错码对数据分组格式*/
const code_block block[13] = {
	{ 1,{ 1,0 },{ 16,10,0,0 } },{ 1,{ 1,0 },{ 28,16,0,0 } },{ 1,{ 1,0 },{ 44,26,0,0 } },
	{ 2,{ 2,0 },{ 32,18,0,0 } },{ 2,{ 2,0 },{ 43,24,0,0 } },{ 4,{ 4,0 },{ 27,16,0,0 } },
	{ 4,{ 4,0 },{ 31,18,0,0 } },{ 4,{ 2,2 },{ 38,22,39,22 } },{ 5,{ 3,2 },{ 36,22,37,22 } },
	{ 5,{ 4,1 },{ 43,26,44,26 } },{ 5,{ 1,4 },{ 50,30,51,30 } },{ 8,{ 6,2 },{ 36,22,37,22 } },
	{ 9,{ 8,1 },{ 37,22,38,22 } }
};

/*生成数据多项式并计算纠错码*/
void code_poly_data(char *data, int level, code ccode[71][71]);
/*生成多项式的生成（多项式乘法） version 1-13,纠错级别M  maxexp为最高次幂*/
int code_poly_born(polynomail &Born, int maxexp);
/*链表生成,n为链表长度（不包括头结点）,maxexp为最高次幂*/
int code_line(polynomail &L, char *data, int n, int maxexp, int choose);
/*将指数相同项合并,在生成链表时，指数相同的项已经相邻，依次释放即可*/
void code_U(polynomail &Born);
/*释放链表，保留头结点*/
void poly_del(polynomail &L);
/*复制拷贝链表到链表*/
void poly_copy(polynomail &copy, polynomail &Born);
/*多项式除法   L是数据多项式，Born是生成多项式*/
void code_poly_divide(polynomail &Born, polynomail &L);
/*每i个结点后插入一个结点(poly_de中插入L)*/
void poly_insert(polynomail &poly_de, polynomail &L, int i);

/*将模式信息等位置填充固定*/
void setsolid(code ccode[71][71], int version);
/*初始设置的区域*/
void code_locate(int level, code ccode[71][71]);
/*输出图形界面*/
void code_show(code ccode[71][71], int version);

/*转存数组数据到二维码框架*/
void code_fill(code ccode[71][71], char *data, int version);
/*转存链表数据到数组*/
void data_change(polynomail &EC, polynomail &data, char *all);

/*掩码的实现*/
void code_mask(code ccode[71][71], int version);

/*格式信息和版本信息*/
void code_format(code ccode[71][71], int version);